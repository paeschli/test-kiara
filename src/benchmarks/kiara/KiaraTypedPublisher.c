/*  KIARA - Middleware for efficient and QoS/Security-aware invocation of services and exchange of messages
 *
 *  Copyright (C) 2013, 2014  German Research Center for Artificial Intelligence (DFKI)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
/*
 * KiaraTypedPublisher.c
 *
 *  Created on: Mar 9, 2014
 *      Author: Dmitri Rubinstein
 */

#include <KIARA/kiara.h>
#include <KIARA/kiara_macros.h>
#include <KIARA/kiara_pp_annotation.h>

#include "MarketData.h"
#include "QuoteRequest.h"
#include "kiara_client_decls.h"
#include "Profiler.h"

#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include "c99fmt.h"

kiara_declare_struct(MarketData,
    kiara_struct_array_member(mdEntries, num_mdEntries))

kiara_declare_struct(QuoteRequest,
    kiara_struct_array_member(related, num_related))

kiara_declare_func(Benchmark_MarketData, MarketData * result_value result, const MarketData *marketData)
kiara_declare_func(Benchmark_QuoteRequest, QuoteRequest * result_value result, const QuoteRequest *quoteRequest)

/*
 * KIARA context and connection variables.
 *
 * KIARA_Context is used for all KIARA operations issued from the single thread.
 * Each separate thread require a separate KIARA_Context instance.
 *
 * KIARA_Connection is a handle to the remote endpoint
 * over which remote calls are performed.
 */
KIARA_Context *ctx;
KIARA_Connection *conn;

/*
 * set_locations and get_locations are handles to the function objects
 * that perform remote call.
 * They are dynamically generated by the KIARA_GENERATE_CLIENT_FUNC macro.
 */
KIARA_FUNC_OBJ(Benchmark_MarketData) benchmark_marketdata;
KIARA_FUNC_OBJ(Benchmark_QuoteRequest) benchmark_quoterequest;

/*
 * Initialization of the connection
 */
void initConn(const char *url)
{
    /* Create new context */

    ctx = kiaraNewContext();

    /* Open connection to the service */

    printf("Opening connection to %s...\n", url);
    conn = kiaraOpenConnection(ctx, url);

    if (!conn)
    {
        fprintf(stderr, "Error: Could not open connection : %s\n", kiaraGetContextError(ctx));
        exit(1);
    }

    /*
     * KIARA_GENERATE_CLIENT_FUNC(connection, idl_method_name, func_type_name, mapping)
     *
     * Generates function that will perform a remote call.
     *
     * connection       - opened and valid KIARA_Connection handle.
     * idl_method_name  - name of the remote service method specified in the IDL.
     * func_type_name   - name of the function object type declared
     *                    with the KIARA_FUNC_OBJ(func_type_name) macro.
     * mapping          - mapping of the IDL types to the application types.
     *                    By default 1:1 mapping by names and types is used.
     *                    Note: mapping is not implemented yet.
     *
     * Note: The IDL of the server application is embedded in aostest_server.c.
     */

    benchmark_marketdata = KIARA_GENERATE_CLIENT_FUNC(conn, "benchmark.marketData", Benchmark_MarketData, "");
    if (!benchmark_marketdata)
        fprintf(stderr, "Error: code generation failed: %s\n", kiaraGetConnectionError(conn));

    benchmark_quoterequest = KIARA_GENERATE_CLIENT_FUNC(conn, "benchmark.quoteRequest", Benchmark_QuoteRequest, "");
    if (!benchmark_quoterequest)
        fprintf(stderr, "Error: code generation failed: %s\n", kiaraGetConnectionError(conn));
}

/*
 * Close connection and finalize KIARA framework
 */
void finalizeConn()
{
    kiaraCloseConnection(conn);
    kiaraFreeContext(ctx);
    kiaraFinalize();
}

int main(int argc, char **argv)
{
    KIARA_Result errorCode;
    MIDDLEWARENEWSBRIEF_PROFILER_TIME_TYPE start, finish, elapsed;
    double latency;
    size_t num_messages;
    MarketData md, mdReply;
    QuoteRequest qr, qrReply;
    const char *url = NULL;

    /* This code is required for testing tool when compiled with MS CRT library and valgrind */
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    /* Initialize KIARA */
    kiaraInit(&argc, argv);

    if (argc > 1)
        url = argv[1];
    else
        url = "http://192.168.56.101:8080/service";

    /* Initialize connection and generate functions */
    initConn(url);

    /* Call remote functions */

    num_messages = 1000;

    printf("Sending %d messages\n", (int)num_messages);

    md = MarketData_createTestData();
    qr = QuoteRequest_createTestData();

    start = MIDDLEWARENEWSBRIEF_PROFILER_GET_TIME;

    {
        size_t i;
        for (i = 0; i < num_messages; ++i)
        {
            // Send 10 MarketDatas for each QuoteRequest
            if (i % 10 == 5)
            {
                qr.counter = i;
                qr.isEcho = 0;
                QuoteRequest_create(&qrReply, 0);
                errorCode = KIARA_CALL(benchmark_quoterequest, &qrReply, &qr);
                QuoteRequest_destroy(&qrReply);
            }
            else
            {
                md.counter = i;
                md.isEcho = 0;
                MarketData_create(&mdReply, 0);
                errorCode = KIARA_CALL(benchmark_marketdata, &mdReply, &md);
                MarketData_destroy(&mdReply);
            }

            if (errorCode != KIARA_SUCCESS)
            {
                fprintf(stderr, "Error: call failed: %s\n", kiaraGetConnectionError(conn));
                break;
            }
        }
    }

    finish = MIDDLEWARENEWSBRIEF_PROFILER_GET_TIME;

    elapsed = MIDDLEWARENEWSBRIEF_PROFILER_DIFF(finish,start);

    latency = (double) elapsed / (num_messages * 2.0);
    printf("\n\nAverage latency in %s: %.3f\n\n\n",
           MIDDLEWARENEWSBRIEF_PROFILER_TIME_UNITS,
           latency);
    printf("Finished\n");

    MarketData_destroy(&md);
    QuoteRequest_destroy(&qr);

    /* Finalize */

    finalizeConn();

    return 0;
}
